# Lab4

---

## Завдання 1

### Опис
- Ця програма демонструє граничні можливості системи щодо виділення динамічної пам’яті через стандартну функцію `malloc()`.
- Програма намагається виділити максимальний обсяг памʼяті, який теоретично може бути переданий у `malloc()` — це `2^64 - 1` байт (≈ 16 ексабайт), що є максимальним значенням типу `size_t` на 64-бітних платформах.
- ![image](https://github.com/user-attachments/assets/66ecded5-2944-498c-b0bb-621442d876b3)

### Пояснення 
- size_t на 64-бітній системі — 8 байтів (тобто 64 біти), отже, максимально можливе значення — 2^64 - 1 (≈ 18.4 ексабайт).
- Але архітектура x86_64 обмежена користувацьким простором адресації до 48 біт. Отже, реально виділити можна до 2^48 (≈ 256 ТБ). Саме тому не 16 ексабайт.

--- 

## Завдання 2

### Опис 

Написана програма демонструє ситуацію, коли розмір памʼяті, що передається у `malloc()`, обчислюється як добуток двох інтів. Якщо результат обчислення переповнює межі типу `int`, `malloc()` отримає некоректне значення, інтерпретоване як велике додатне число типу `size_t`.

У результаті:
- `malloc()` може повернути `NULL`,
- або в кращому випадку — відмовити у виділенні пам’яті з повідомленням `Cannot allocate memory`,
- або в гіршому випадку — викликати помилкову поведінку або `segfault`.
- ![image](https://github.com/user-attachments/assets/1d18f178-3168-474e-bfc1-73462861942b)

---

## Завдання 3

### Опис
Ця програма демонструє поведінку стандартної функції `malloc(3)` при передачі нульового розміру — `malloc(0)`. Згідно зі стандартом C, така операція є допустимою, але її результат **не визначений однозначно**:

У результаті:
- `malloc(0)` **може повернути `NULL`**,
- або **може повернути унікальний, але недійсний для доступу вказівник**, який однак **можна передати у `free()` без помилок**.
![image](https://github.com/user-attachments/assets/7a731e0e-5a69-4ed9-a997-49c4ef577bb1)
