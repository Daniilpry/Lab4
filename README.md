# Lab4

---

## Завдання 1

### Опис
- Ця програма демонструє граничні можливості системи щодо виділення динамічної пам’яті через стандартну функцію `malloc()`.
- Програма намагається виділити максимальний обсяг памʼяті, який теоретично може бути переданий у `malloc()` — це `2^64 - 1` байт (≈ 16 ексабайт), що є максимальним значенням типу `size_t` на 64-бітних платформах.
- ![image](https://github.com/user-attachments/assets/66ecded5-2944-498c-b0bb-621442d876b3)

### Пояснення 
- size_t на 64-бітній системі — 8 байтів (тобто 64 біти), отже, максимально можливе значення — 2^64 - 1 (≈ 18.4 ексабайт).
- Але архітектура x86_64 обмежена користувацьким простором адресації до 48 біт. Отже, реально виділити можна до 2^48 (≈ 256 ТБ). Саме тому не 16 ексабайт.

--- 

## Завдання 2

### Опис 

Написана програма демонструє ситуацію, коли розмір памʼяті, що передається у `malloc()`, обчислюється як добуток двох інтів. Якщо результат обчислення переповнює межі типу `int`, `malloc()` отримає некоректне значення, інтерпретоване як велике додатне число типу `size_t`.

У результаті:
- `malloc()` може повернути `NULL`,
- або в кращому випадку — відмовити у виділенні пам’яті з повідомленням `Cannot allocate memory`,
- або в гіршому випадку — викликати помилкову поведінку або `segfault`.
- ![image](https://github.com/user-attachments/assets/1d18f178-3168-474e-bfc1-73462861942b)

---

## Завдання 3

### Опис
Ця програма демонструє поведінку стандартної функції `malloc(3)` при передачі нульового розміру — `malloc(0)`. Згідно зі стандартом C, така операція є допустимою, але її результат **не визначений однозначно**:

У результаті:
- `malloc(0)` **може повернути `NULL`**,
- або **може повернути унікальний, але недійсний для доступу вказівник**, який однак **можна передати у `free()` без помилок**.
- ![image](https://github.com/user-attachments/assets/7a731e0e-5a69-4ed9-a997-49c4ef577bb1)

---

## Завдання 4

### Опис 
Так, у коді наданому в завданні дійсно є помилка:
- ptr ініціалізується NULL, і у кожній ітерації:
  - якщо ptr == NULL, виконується malloc(n)
  - потім використовується ptr
  - потім завжди викликається free(ptr)

- Але ptr не обнуляється після free(), тому на наступній ітерації:
  - ptr != NULL, отже malloc(n) не викликається
  - ptr вказує на вже звільнену область

Було б розумно додати 'ptr = NULL;' після 'free(ptr);'. Таким чином ми будемо обнуляти після free(ptr). 

### Ось код зі змінами про які я вказав вище
```c
void *ptr = NULL;
while (<some-condition-is-true>) {
    ptr = malloc(n);
    if (!ptr) {
        break;
    }

    // ... використання 'ptr' ...

    free(ptr);
    ptr = NULL;    //обнуляємо після free
}
```

---

## Завдання 5

### Опис
Ця програма демонструє, як **правильно обробляти помилку** при використанні `realloc()`. Якщо `realloc()` не може виділити нову памʼять, вона повертає `NULL`, але:
  - **НЕ звільняє стару памʼять**;
  - якщо результат одразу записати назад у той самий поінтер (`ptr = realloc(ptr, ...)`), **втрачається доступ до старої області**, що призводить до **витоку памʼяті**.
  - ![image](https://github.com/user-attachments/assets/c5d992e8-0882-4bec-94c8-ca980ff0251f)

---

## Завдання 6

### Опис
Ця програма демонструє дві  ситуації при використанні функції `realloc(3)`:
  - **`realloc(NULL, size)`** — еквівалентно `malloc(size)`, тобто виділяє нову пам’ять.
  - **`realloc(ptr, 0)`** — еквівалентно `free(ptr)`, функція звільняє пам’ять і повертає `NULL`.
  - ![image](https://github.com/user-attachments/assets/2731da7e-e092-45f9-802d-93cc88416b64)

--- 

## Завдання 7

### Опис
Цей приклад демонструє, як використовувати `reallocarray(3)` замість традиційного `realloc()` для безпечного перевиділення памʼяті. На відміну від `realloc(ptr, nmemb * size)`, функція `reallocarray(ptr, nmemb, size)` виконує перевірку на переповнення при множенні `nmemb * size`, що допомагає уникнути вразливостей.

### Результати
- Запускати програму варто з використання ltrace, це утиліта для налагодження яка відображає виклики які перехоплює та записує до динамічної бібліотеки.

При використанні realloc():
```
ltrace ./zd7
calloc(1000, 16) = 0x55555575f260
realloc(0x55555575f260, 8000) = 0x5555557602a0
free(0x5555557602a0)
```

При використанні reallocarray():
```
ltrace ./zd7
calloc(1000, 16) = 0x55555575f260
reallocarray(0x55555575f260, 500, 16) = 0x5555557602a0
free(0x5555557602a0)
```
